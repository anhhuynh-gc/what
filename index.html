<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RDP Latency Detector (Robust Method)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
  <style>
    :root {
      --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
      --card-bg: rgba(255, 255, 255, 0.03);
      --card-border: 1px solid rgba(255, 255, 255, 0.08);
      --highlight: #818cf8;
      --highlight-dim: rgba(129, 140, 248, 0.2);
      --signal-safe: #34d399;
      --signal-warn: #fbbf24;
      --text-main: #e2e8f0;
      --text-muted: #94a3b8;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg-gradient);
      min-height: 100vh;
      color: var(--text-main);
      padding: 2rem;
      display: flex;
      justify-content: center;
    }

    .container { width: 100%; max-width: 1000px; }

    /* Header */
    header { text-align: center; margin-bottom: 2rem; }
    h1 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      background: linear-gradient(90deg, #818cf8, #c084fc);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .subtitle { color: var(--text-muted); font-size: 0.95rem; }

    /* Input Section */
    .input-section {
      background: var(--card-bg);
      border: var(--card-border);
      border-radius: 16px;
      padding: 2rem;
      margin-bottom: 2rem;
      text-align: center;
      transition: border-color 0.2s;
    }
    .input-section:focus-within { border-color: var(--highlight); }

    #typing-input {
      width: 100%;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 1.2rem;
      font-size: 1.25rem;
      color: #fff;
      outline: none;
      transition: all 0.2s;
    }
    #typing-input:focus { background: rgba(0, 0, 0, 0.4); border-color: var(--highlight); }
    
    .key-monitor {
      margin-top: 1rem;
      min-height: 24px;
      font-family: monospace;
      color: var(--highlight);
      font-size: 1rem;
    }

    /* Grid Layout for Stats */
    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    
    @media (max-width: 768px) {
      .dashboard-grid { grid-template-columns: 1fr; }
    }

    .panel {
      background: var(--card-bg);
      border: var(--card-border);
      border-radius: 16px;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
    }
    
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      padding-bottom: 0.75rem;
    }
    .panel-title { font-size: 1rem; font-weight: 600; color: #fff; }
    .panel-badge { 
      font-size: 0.7rem; padding: 2px 8px; border-radius: 12px; 
      background: rgba(255,255,255,0.1); color: var(--text-muted);
    }

    /* Stats Cards */
    .stats-row {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
    }
    .stat-box {
      background: rgba(255,255,255,0.02);
      padding: 1rem;
      border-radius: 12px;
      text-align: center;
    }
    .stat-label { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
    .stat-val { font-size: 1.5rem; font-weight: 700; color: #fff; }
    .stat-unit { font-size: 0.75rem; color: var(--text-muted); }
    
    .robust-val { color: var(--signal-safe); }
    .highlight-val { color: var(--highlight); }

    /* Chart */
    .chart-container {
      background: var(--card-bg);
      border: var(--card-border);
      border-radius: 16px;
      padding: 1.5rem;
      height: 300px;
      margin-bottom: 2rem;
      position: relative;
    }

    /* Controls */
    .controls { display: flex; justify-content: center; gap: 1rem; }
    .btn {
      background: var(--card-bg);
      border: 1px solid rgba(255,255,255,0.1);
      color: var(--text-main);
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }
    .btn:hover { background: rgba(255,255,255,0.1); transform: translateY(-1px); }
    .btn-primary {
      background: linear-gradient(135deg, #6366f1, #a855f7);
      border: none;
      color: white;
    }
    .btn-primary:hover { opacity: 0.9; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3); }

    /* Helper text */
    .explainer { font-size: 0.8rem; color: var(--text-muted); margin-top: 1rem; line-height: 1.4; }
  </style>
</head>
<body>

  <div class="container">
    <header>
      <h1>RDP Latency Detector</h1>
      <p class="subtitle">Robust Dwell Time Analysis (Winsorized Median + IQR)</p>
    </header>

    <div class="input-section">
      <input type="text" id="typing-input" placeholder="Type naturally here (including hold-down errors)..." autocomplete="off">
      <div id="key-status" class="key-monitor">&nbsp;</div>
    </div>

    <div class="dashboard-grid">
      
      <div class="panel">
        <div class="panel-header">
          <span class="panel-title">Raw Statistics</span>
          <span class="panel-badge">Includes Outliers</span>
        </div>
        <div class="stats-row">
          <div class="stat-box">
            <div class="stat-label">Raw Median</div>
            <div class="stat-val" id="raw-median">--</div>
            <div class="stat-unit">ms</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Raw P99</div>
            <div class="stat-val" id="raw-p99">--</div>
            <div class="stat-unit">ms</div>
          </div>
        </div>
        <div class="explainer">
          Standard P99 spikes easily if you hold a key down. This causes false positives.
        </div>
      </div>

      <div class="panel" style="border-color: rgba(52, 211, 153, 0.2);">
        <div class="panel-header">
          <span class="panel-title" style="color: var(--signal-safe)">RDP Signals</span>
          <span class="panel-badge">Top 5% Trimmed</span>
        </div>
        <div class="stats-row">
          <div class="stat-box">
            <div class="stat-label">Robust Median</div>
            <div class="stat-val robust-val" id="robust-median">--</div>
            <div class="stat-unit">Network Shift</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">IQR (Jitter)</div>
            <div class="stat-val robust-val" id="robust-iqr">--</div>
            <div class="stat-unit">Consistency</div>
          </div>
        </div>
        <div class="explainer">
          Outliers removed. High "Robust Median" + High "IQR" = Strong RDP Indicator.
        </div>
      </div>

    </div>

    <div class="chart-container">
      <canvas id="mainChart"></canvas>
    </div>

    <div class="controls">
      <button class="btn" id="btn-clear">Reset Data</button>
      <div style="font-size: 0.8rem; color: #64748b; align-self: center;">Samples: <span id="sample-count">0</span></div>
    </div>
  </div>

<script>
/**
 * RDP DETECTION LOGIC
 * 1. Collect Dwell Times
 * 2. Trim top 5% (Winsorization/Truncation) to remove key-hold outliers
 * 3. Calculate Median of remainder (Central Tendency)
 * 4. Calculate IQR of remainder (Network Jitter)
 */

// State
let rawDurations = [];
const TRIM_PERCENTAGE = 0.05; // Remove top 5%
const CHART_BINS = 20;

// DOM Elements
const els = {
  input: document.getElementById('typing-input'),
  status: document.getElementById('key-status'),
  count: document.getElementById('sample-count'),
  rawMedian: document.getElementById('raw-median'),
  rawP99: document.getElementById('raw-p99'),
  robustMedian: document.getElementById('robust-median'),
  robustIQR: document.getElementById('robust-iqr'),
  clearBtn: document.getElementById('btn-clear')
};

// --- Statistics Functions ---

// Helper: Get percentile from sorted array
function getPercentile(sortedArr, p) {
  if (sortedArr.length === 0) return 0;
  const index = (p / 100) * (sortedArr.length - 1);
  const lower = Math.floor(index);
  const upper = Math.ceil(index);
  const weight = index - lower;
  return sortedArr[lower] * (1 - weight) + sortedArr[upper] * weight;
}

// Core Logic: Robust Stats Calculation
function calculateStats() {
  if (rawDurations.length === 0) return resetStats();

  // 1. Sort Data
  const sorted = [...rawDurations].sort((a, b) => a - b);

  // 2. Raw Stats (for comparison)
  const rawMed = getPercentile(sorted, 50);
  const raw99 = getPercentile(sorted, 99);

  // 3. Robust Logic: Trim Top 5%
  // We keep the bottom 95% of data. 
  // If we have 100 samples, we keep indices 0 to 94.
  const cutOffIndex = Math.floor(sorted.length * (1 - TRIM_PERCENTAGE));
  const trimmedData = sorted.slice(0, cutOffIndex); // The clean dataset

  if (trimmedData.length === 0) return resetStats();

  // 4. Robust Metrics on Trimmed Data
  const robustMed = getPercentile(trimmedData, 50);
  const p25 = getPercentile(trimmedData, 25);
  const p75 = getPercentile(trimmedData, 75);
  const iqr = p75 - p25;

  // 5. Update UI
  els.count.textContent = rawDurations.length;
  
  els.rawMedian.textContent = rawMed.toFixed(0);
  els.rawP99.textContent = raw99.toFixed(0);
  
  els.robustMedian.textContent = robustMed.toFixed(0);
  els.robustIQR.textContent = iqr.toFixed(0);

  updateChart(sorted, trimmedData[trimmedData.length-1]);
}

function resetStats() {
  els.rawMedian.textContent = '--';
  els.rawP99.textContent = '--';
  els.robustMedian.textContent = '--';
  els.robustIQR.textContent = '--';
  updateChart([], 0);
}

// --- Chart.js Setup ---
const ctx = document.getElementById('mainChart').getContext('2d');
const chart = new Chart(ctx, {
  type: 'bar',
  data: {
    labels: [],
    datasets: [
      {
        label: 'Normal Keystrokes',
        data: [],
        backgroundColor: '#6366f1',
        borderRadius: 4,
        order: 2
      },
      {
        label: 'Trimmed Outliers (Top 5%)',
        data: [],
        backgroundColor: 'rgba(251, 191, 36, 0.4)', // Yellow/Warn color
        borderRadius: 4,
        order: 1
      }
    ]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    animation: false,
    plugins: {
      legend: { position: 'top', labels: { color: '#94a3b8' } },
      tooltip: { mode: 'index', intersect: false }
    },
    scales: {
      x: { 
        title: { display: true, text: 'Dwell Time (ms)', color: '#64748b' },
        grid: { color: 'rgba(255,255,255,0.05)' },
        ticks: { color: '#94a3b8' }
      },
      y: { 
        display: false 
      }
    }
  }
});

function updateChart(sortedData, trimThreshold) {
  if (sortedData.length === 0) {
    chart.data.labels = [];
    chart.data.datasets[0].data = [];
    chart.data.datasets[1].data = [];
    chart.update();
    return;
  }

  // Determine Range
  const maxVal = Math.max(...sortedData); // Or cap at reasonable visual max like 500ms
  // Let's cap visual chart at 500ms or max value if smaller, to keep RDP range visible
  const visualMax = Math.max(200, Math.min(maxVal, 1000));
  const binSize = visualMax / CHART_BINS;

  // Init Bins
  const labels = [];
  const normalBins = new Array(CHART_BINS).fill(0);
  const outlierBins = new Array(CHART_BINS).fill(0);

  for (let i = 0; i < CHART_BINS; i++) {
    const start = Math.floor(i * binSize);
    const end = Math.floor((i + 1) * binSize);
    labels.push(`${start}-${end}`);
  }
  labels.push(`>${Math.floor(visualMax)}`);
  normalBins.push(0); 
  outlierBins.push(0);

  // Fill Bins
  sortedData.forEach(val => {
    let idx = Math.floor(val / binSize);
    if (idx >= CHART_BINS) idx = CHART_BINS; // Overflow bin

    // Visual separation: is this value inside the trim threshold?
    if (val <= trimThreshold) {
      normalBins[idx]++;
    } else {
      outlierBins[idx]++;
    }
  });

  chart.data.labels = labels;
  chart.data.datasets[0].data = normalBins;
  chart.data.datasets[1].data = outlierBins;
  chart.update();
}

// --- Key Event Listeners ---
const pendingKeys = new Map();

els.input.addEventListener('keydown', e => {
  if (e.repeat) return;
  // Ignore modifier keys alone
  if (['Shift', 'Control', 'Alt', 'Meta'].includes(e.key)) return;
  
  pendingKeys.set(e.code, performance.now());
  els.status.innerHTML = `Holding: <span style="color:#fff">${e.key}</span>`;
});

els.input.addEventListener('keyup', e => {
  if (!pendingKeys.has(e.code)) return;
  
  const startTime = pendingKeys.get(e.code);
  const duration = performance.now() - startTime;
  pendingKeys.delete(e.code);

  rawDurations.push(duration);
  els.status.innerHTML = `Released: <span style="color:#fff">${e.key}</span> (${duration.toFixed(0)}ms)`;
  
  calculateStats();
});

els.clearBtn.addEventListener('click', () => {
  rawDurations = [];
  pendingKeys.clear();
  els.input.value = '';
  els.status.innerHTML = '&nbsp;';
  calculateStats();
});

// Init
els.input.focus();
</script>
</body>
</html>
